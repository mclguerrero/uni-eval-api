/**
 * Script para generar JSON Schemas base desde schema.prisma
 * Lee los modelos de Prisma y genera schemas estructurales sin reglas de negocio
 */

const fs = require('fs');
const path = require('path');

/**
 * Mapeo de tipos Prisma a JSON Schema
 */
const PRISMA_TO_JSON_SCHEMA_TYPE_MAP = {
  // Tipos num√©ricos
  Int: { type: 'integer' },
  BigInt: { type: 'integer' },
  Float: { type: 'number' },
  Decimal: { type: 'number' },
  
  // Tipos string
  String: { type: 'string' },
  
  // Tipos booleanos
  Boolean: { type: 'boolean' },
  
  // Tipos fecha/hora
  DateTime: { type: 'string', format: 'date-time' },
  
  // Tipos especiales
  Json: { type: 'object' },
  Bytes: { type: 'string', contentEncoding: 'base64' }
};

/**
 * Clase para parsear schema.prisma
 */
class PrismaSchemaParser {
  constructor(schemaPath) {
    this.schemaPath = schemaPath;
    this.schemaContent = '';
    this.models = new Map();
  }

  /**
   * Lee el archivo schema.prisma
   */
  readSchema() {
    try {
      this.schemaContent = fs.readFileSync(this.schemaPath, 'utf-8');
      return true;
    } catch (error) {
      console.error(`Error leyendo schema: ${error.message}`);
      return false;
    }
  }

  /**
   * Extrae todos los modelos del schema
   */
  parseModels() {
    // Regex para encontrar modelos
    const modelRegex = /model\s+(\w+)\s*\{([^}]+)\}/g;
    let match;

    while ((match = modelRegex.exec(this.schemaContent)) !== null) {
      const modelName = match[1];
      const modelBody = match[2];
      
      const fields = this.parseFields(modelBody);
      this.models.set(modelName, fields);
    }

    return this.models;
  }

  /**
   * Parsea los campos de un modelo
   */
  parseFields(modelBody) {
    const fields = [];
    const lines = modelBody.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      
      // Ignorar l√≠neas vac√≠as, comentarios, @@
      if (!trimmed || trimmed.startsWith('//') || trimmed.startsWith('@@')) {
        continue;
      }

      const field = this.parseField(trimmed);
      if (field) {
        fields.push(field);
      }
    }

    return fields;
  }

  /**
   * Parsea una l√≠nea de campo individual
   */
  parseField(line) {
    // Regex para parsear: nombre tipo modificador? @atributos?
    const fieldRegex = /^(\w+)\s+(\w+)(\[\])?([\?\!])?\s*(@.*)?$/;
    const match = line.match(fieldRegex);

    if (!match) return null;

    const [, name, type, isArray, modifier, attributes] = match;

    return {
      name,
      type,
      isArray: !!isArray,
      isOptional: modifier === '?',
      isRequired: modifier === '!',
      attributes: attributes || '',
      rawLine: line
    };
  }

  /**
   * Convierte los campos parseados a propiedades JSON Schema
   */
  fieldsToJsonSchema(fields, options = {}) {
    const properties = {};
    const required = [];

    for (const field of fields) {
      // Ignorar campos de relaci√≥n (inician con min√∫scula y son objetos Prisma)
      if (this.isRelationField(field)) {
        continue;
      }

      // Ignorar campos auto-generados por defecto (a menos que se especifique)
      if (this.shouldSkipField(field, options)) {
        continue;
      }

      const property = this.fieldToProperty(field);
      if (property) {
        properties[field.name] = property;

        // Agregar a required si no es opcional y no tiene default
        if (!field.isOptional && !this.hasDefault(field)) {
          required.push(field.name);
        }
      }
    }

    return { properties, required };
  }

  /**
   * Convierte un campo Prisma a una propiedad JSON Schema
   */
  fieldToProperty(field) {
    const baseType = PRISMA_TO_JSON_SCHEMA_TYPE_MAP[field.type];
    
    if (!baseType) {
      // Tipo no reconocido (probablemente una relaci√≥n)
      return null;
    }

    let property = { ...baseType };

    // Si es array
    if (field.isArray) {
      property = {
        type: 'array',
        items: property
      };
    }

    // Agregar descripci√≥n desde @db o comentarios si existen
    const description = this.extractDescription(field);
    if (description) {
      property.description = description;
    }

    return property;
  }

  /**
   * Determina si un campo es una relaci√≥n
   */
  isRelationField(field) {
    // Si el tipo no est√° en nuestro mapeo, probablemente es una relaci√≥n
    return !PRISMA_TO_JSON_SCHEMA_TYPE_MAP[field.type];
  }

  /**
   * Determina si un campo debe ser omitido
   */
  shouldSkipField(field, options = {}) {
    const { includeAutoGenerated = false, includeTimestamps = false } = options;

    // Siempre omitir campos de relaci√≥n
    if (this.isRelationField(field)) {
      return true;
    }

    // Omitir id si es autoincrement (a menos que se especifique)
    if (field.name === 'id' && !includeAutoGenerated && field.attributes.includes('@default(autoincrement())')) {
      return true;
    }

    // Omitir timestamps por defecto
    if (!includeTimestamps && this.isTimestampField(field)) {
      return true;
    }

    return false;
  }

  /**
   * Verifica si un campo tiene valor por defecto
   */
  hasDefault(field) {
    return field.attributes.includes('@default');
  }

  /**
   * Verifica si un campo es timestamp
   */
  isTimestampField(field) {
    const timestampFields = ['fecha_creacion', 'fecha_actualizacion', 'created_at', 'updated_at'];
    return timestampFields.includes(field.name) && field.attributes.includes('@default');
  }

  /**
   * Extrae descripci√≥n del campo (si existe en comentarios)
   */
  extractDescription(field) {
    // Buscar comentarios en la misma l√≠nea o l√≠nea anterior
    // Por ahora, retornar null (se puede extender)
    return null;
  }

  /**
   * Genera el JSON Schema completo para un modelo
   */
  generateSchemaForModel(modelName, options = {}) {
    const fields = this.models.get(modelName);
    if (!fields) {
      throw new Error(`Modelo '${modelName}' no encontrado`);
    }

    const { properties, required } = this.fieldsToJsonSchema(fields, options);

    return {
      $schema: 'http://json-schema.org/draft-07/schema#',
      type: 'object',
      title: modelName,
      properties,
      required: required.length > 0 ? required : undefined,
      additionalProperties: false
    };
  }

  /**
   * Genera schemas para todos los modelos
   */
  generateAllSchemas(options = {}) {
    const schemas = {};
    
    for (const [modelName] of this.models) {
      try {
        schemas[modelName] = this.generateSchemaForModel(modelName, options);
      } catch (error) {
        console.error(`Error generando schema para ${modelName}: ${error.message}`);
      }
    }

    return schemas;
  }
}

/**
 * Funci√≥n principal para generar schemas
 */
function generateJsonSchemas(schemaPath, outputDir, options = {}) {
  console.log('üîÑ Iniciando generaci√≥n de JSON Schemas...');
  
  const parser = new PrismaSchemaParser(schemaPath);
  
  // Leer y parsear el schema
  if (!parser.readSchema()) {
    console.error('‚ùå Error leyendo schema.prisma');
    return false;
  }

  parser.parseModels();
  console.log(`‚úÖ ${parser.models.size} modelos encontrados`);

  // Generar schemas
  const schemas = parser.generateAllSchemas(options);

  // Crear directorio de salida si no existe
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Guardar cada schema en un archivo
  let savedCount = 0;
  for (const [modelName, schema] of Object.entries(schemas)) {
    const filename = `${modelName}.schema.json`;
    const filepath = path.join(outputDir, filename);
    
    try {
      fs.writeFileSync(filepath, JSON.stringify(schema, null, 2));
      savedCount++;
      console.log(`  ‚úì ${filename}`);
    } catch (error) {
      console.error(`  ‚úó Error guardando ${filename}: ${error.message}`);
    }
  }

  // Guardar un archivo index con todos los schemas
  const indexPath = path.join(outputDir, 'index.json');
  try {
    fs.writeFileSync(indexPath, JSON.stringify(schemas, null, 2));
    console.log(`\n‚úÖ Schemas guardados en: ${outputDir}`);
    console.log(`üì¶ Total: ${savedCount} schemas generados`);
  } catch (error) {
    console.error(`Error guardando index: ${error.message}`);
  }

  return true;
}

/**
 * Ejecuci√≥n como script CLI
 */
if (require.main === module) {
  const args = process.argv.slice(2);
  
  const schemaPath = args[0] || path.join(__dirname, '../prisma/schema.prisma');
  const outputDir = args[1] || path.join(__dirname, '../scripts/generated/schemas');
  
  const options = {
    includeAutoGenerated: args.includes('--include-id'),
    includeTimestamps: args.includes('--include-timestamps')
  };

  console.log(`Schema: ${schemaPath}`);
  console.log(`Output: ${outputDir}`);
  console.log(`Options:`, options);
  console.log('---');

  generateJsonSchemas(schemaPath, outputDir, options);
}

module.exports = {
  PrismaSchemaParser,
  generateJsonSchemas,
  PRISMA_TO_JSON_SCHEMA_TYPE_MAP
};
